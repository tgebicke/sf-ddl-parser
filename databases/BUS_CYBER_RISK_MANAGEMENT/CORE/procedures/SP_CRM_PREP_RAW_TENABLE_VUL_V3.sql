CREATE OR REPLACE PROCEDURE "SP_CRM_PREP_RAW_TENABLE_VUL_V3"("P_SNAPSHOT_ID" NUMBER(38,0))
RETURNS VARCHAR(16777216)
LANGUAGE SQL
COMMENT='Prep/Validate RAW_TENABLE_VUL data'
EXECUTE AS OWNER
AS '
DECLARE
Appl varchar := ''SP_CRM_PREP_RAW_TENABLE_VUL_V3'';
ExceptionMsg varchar := ''Default'';
Msg varchar;
StartOfProcedure datetime := current_timestamp();
CRM_logic_exception exception (-20002, ''Raised CRM_logic_exception.'');
False boolean := 0;
True boolean := 1;
AWS_VUL varchar := ''AWS VUL'';
CCIC_VUL varchar := ''CCIC VUL'';
AWS_VUL_MITIGATED varchar := ''AWS VUL MITIGATED''; -- 240118
CCIC_VUL_MITIGATED varchar := ''CCIC VUL MITIGATED''; -- 240118
MAG_VUL varchar := ''MAG VUL''; -- 241023 CR1012
MAG_VUL_MITIGATED varchar := ''MAG VUL MITIGATED''; -- 241023 CR1012
RECORD_COUNT NUMBER;
RECORDS_WITH_ERRORS NUMBER;
RECORDS_WITH_WARNINGS NUMBER;
ERROR_COUNT NUMBER;
WARNING_COUNT NUMBER;
DATACATEGORY VARCHAR;
IS_FROM_AWS_FEED BOOLEAN;

BEGIN
select DATACATEGORY,IS_FROM_AWS_FEED into :DATACATEGORY,:IS_FROM_AWS_FEED FROM CORE.SNAPSHOT_IDS where SNAPSHOT_ID = :P_SNAPSHOT_ID;
Appl := :Appl || ''('' || DATACATEGORY || '')''; -- This helps to clarify which VUL we are processing
CALL CORE.SP_CRM_START_PROCEDURE (:Appl);

--
-- 240710 CR928 
-- Moved initialization of RAW_TENABLE_VUL to respective PULL stored procedure so the fields are 
-- initialized upon write to RAW_TENABLE_VUL
--

select count(1) into :RECORD_COUNT FROM CORE.RAW_TENABLE_VUL where SNAPSHOT_ID = :P_SNAPSHOT_ID and RowDisposition = CORE.FN_CRM_GET_ROWDISPOSITION_VIABLE();

IF (:RECORD_COUNT = 0) THEN
	BEGIN
	Msg := ''WARNING: There is no VUL data for this snapshot'';
	CALL CORE.SP_CRM_WRITE_MSGLOG (:Appl,:Msg);
    CALL CORE.SP_CRM_END_PROCEDURE (:Appl);
	RETURN :Msg;
	END;
END IF;

--
-- INSERT MOST CURRENT TENABLE REPOSITORY HISTORY
--
INSERT INTO CORE.TENABLE_REPOSITORYHIST (
	DATACENTER_ID,
	INSERT_DATE,
    IS_FROM_AWS_FEED,
	LAST_SEEN,
    RAW_TENABLE_VUL_COUNT,
    REPOSITORY_ID,
	REPOSITORY_NAME
)
select repo.DATACENTER_ID,repo.Max_INSERT_DATE,:IS_FROM_AWS_FEED,repo.Max_LAST_SEEN,repo.RAW_TENABLE_VUL_COUNT,repo.REPOSITORY_ID,repo.REPOSITORY_NAME
FROM (select 
    dc.SYSTEM_ID as DATACENTER_ID
    ,MAX(r.INSERT_DATE) as Max_INSERT_DATE
    ,MAX(r.LAST_SEEN) as Max_LAST_SEEN
    ,r.REPOSITORY_ID
    ,r.REPOSITORY_NAME
    ,count(1) RAW_TENABLE_VUL_COUNT
    from RAW_TENABLE_VUL r
    JOIN CORE.SYSTEMS dc on upper(dc.SYSTEM_ID) = upper(r.DATACENTER_ID)
    WHERE r.SNAPSHOT_ID = :P_SNAPSHOT_ID and r.REPOSITORY_ID IS NOT NULL
    GROUP BY dc.SYSTEM_ID,r.REPOSITORY_ID,r.REPOSITORY_NAME) repo
LEFT OUTER JOIN CORE.TENABLE_REPOSITORYHIST t on t.DATACENTER_ID = repo.DATACENTER_ID and t.REPOSITORY_ID = repo.REPOSITORY_ID and t.INSERT_DATE = repo.Max_INSERT_DATE
WHERE t.TENABLE_REPOSITORYHIST_ID IS NULL;

RECORD_COUNT := SQLROWCOUNT;
Msg := ''TENABLE_REPOSITORYHIST inserted='' || :RECORD_COUNT;
CALL CORE.SP_CRM_WRITE_MSGLOG (:Appl,:Msg); 

--
-- Derive FISMASEVERITY and NUMERIC_SEVERITY
--
-- 240911 CR976 Emergency Break Fix
-- Case statement was using NUMERIC_SEVERITY to set FISMASEVERITY which incorrectly used the pre-existing record value of zero
--
-- 240712 CR928 was multiple queries
--
-- 231012 move from CVSSV2 to CVSSV3; CVSS3 score ranges from https://nvd.nist.gov/vuln-metrics/cvss
-- Under CVSSV2 then ranges were as follows
--  Critical 10.0
--  High BETWEEN 7.0 AND 9.9
--  Medium	BETWEEN 4.0 AND 6.9
--  Low  BETWEEN 0.1 AND 3.9
--
UPDATE CORE.RAW_TENABLE_VUL
set NUMERIC_SEVERITY = IFF(CVSSV3BASESCORE >= 9.0,4,IFF(CVSSV3BASESCORE >= 7.0,3,IFF(CVSSV3BASESCORE >= 4.0,2,IFF(CVSSV3BASESCORE >= 0.1,1,0))))
,FISMASEVERITY = case IFF(CVSSV3BASESCORE >= 9.0,4,IFF(CVSSV3BASESCORE >= 7.0,3,IFF(CVSSV3BASESCORE >= 4.0,2,IFF(CVSSV3BASESCORE >= 0.1,1,0))))
    when 4 then ''Critical''
    when 3 then ''High''
    when 2 then ''Medium''
    when 1 then ''Low''
    when 0 then ''Info'' -- 240909
    Else ''Unknown''
End
WHERE SNAPSHOT_ID = :P_SNAPSHOT_ID;


If (:DATACATEGORY IN (:CCIC_VUL,:CCIC_VUL_MITIGATED)) THEN
    BEGIN
    BEGIN TRANSACTION; 
    --
    -- 240727 CR928
    -- Assign metadata already determined by SP_CRM_LINK_METADATA_V2
    --
    UPDATE CORE.RAW_TENABLE_VUL upd
    set DATACENTER_ID = met.DATACENTER_ID
    ,SYSTEM_ID = met.SYSTEM_ID
    ,ASSET_ID_TATTOO = met.ASSET_ID_TATTOO
    ,CREDENTIALED_SCAN = met.IS_TENABLE_CREDENTIALED_SCAN::number
    ,ASSET_ID_TAG = met.ASSET_ID_TATTOO
    ,FISMA_ID_TAG = met.SYSTEM_ID
-- 240729 TEMPOARARY DISABLE UNTIL RESOLVED    ,DATA_ERROR_ARRAY = ARRAY_APPEND(r.DATA_ERROR_ARRAY,met.DATA_ERROR_ARRAY) -- Inherit metadata errors
-- 240729 TEMPOARARY DISABLE UNTIL RESOLVED    ,DATA_WARNING_ARRAY = ARRAY_APPEND(r.DATA_WARNING_ARRAY,met.DATA_WARNING_ARRAY) -- Inherit metadata warnings
    FROM CORE.RAW_TENABLE_VUL r
    JOIN TEMP_ASSET_METADATA met on met.TEMP_DW_ASSET_ID = r.TEMP_DW_ASSET_ID
    WHERE r.SNAPSHOT_ID = :P_SNAPSHOT_ID 
    and upd.RAW_TENABLE_VUL_ID = r.RAW_TENABLE_VUL_ID;

    RECORD_COUNT := SQLROWCOUNT;

    Msg := ''CCIC metadata assigned='' || :RECORD_COUNT;
    CALL CORE.SP_CRM_WRITE_MSGLOG (:Appl,:Msg);
    COMMIT;
    END;
End If;

BEGIN TRANSACTION; -- 240814 move this code to this point. (Was above TEMP_ASSET_METADATA)
--
-- 240410 CR 867 Implement DRaaS multi-tenant tag
--
UPDATE CORE.RAW_TENABLE_VUL upd
set ASSET_ID_TATTOO = p.ASSET_ID_TATTOO -- 240912 CR978
,DATACENTER_ID = p.DATACENTER_ID -- 240912 CR978
,TENANT_ID = p.TENANT_ID -- 240912 CR978
FROM CORE.RAW_TENABLE_VUL r
join table(CORE.FN_CRM_PARSE_DRAAS_ASSET_ID_TATTOO(r.ASSET_ID_TAG)) p -- 240912 CR978
where r.SNAPSHOT_ID = :P_SNAPSHOT_ID 
and CORE.FN_CRM_IS_VALID_DRAAS_ASSET_ID_TATTOO(r.ASSET_ID_TAG) = 1 -- 240912 CR978
and r.ASSET_ID_TAG IS NOT NULL -- 240916 1459 CR978
and upd.RAW_TENABLE_VUL_ID = r.RAW_TENABLE_VUL_ID;

RECORD_COUNT := SQLROWCOUNT;

Msg := ''Tenant tags assigned='' || :RECORD_COUNT;
CALL CORE.SP_CRM_WRITE_MSGLOG (:Appl,:Msg);
COMMIT;


If (:DATACATEGORY IN (:AWS_VUL,:AWS_VUL_MITIGATED)) THEN
    BEGIN
    BEGIN TRANSACTION; 
    --
    -- 240727 CR928
    -- Assign CREDENTIALED_SCAN already determined by SP_CRM_LINK_METADATA_V2
    -- Since views already handle SYSTEM_ID and ASSET_ID_TATTOO, we are only interested in CREDENTIALED_SCAN
    --
    UPDATE CORE.RAW_TENABLE_VUL upd
    set CREDENTIALED_SCAN = met.IS_TENABLE_CREDENTIALED_SCAN::number
-- 240729 TEMPOARARY DISABLE UNTIL RESOLVED    ,DATA_ERROR_ARRAY = ARRAY_APPEND(r.DATA_ERROR_ARRAY,met.DATA_ERROR_ARRAY) -- Inherit metadata errors
-- 240729 TEMPOARARY DISABLE UNTIL RESOLVED    ,DATA_WARNING_ARRAY = ARRAY_APPEND(r.DATA_WARNING_ARRAY,met.DATA_WARNING_ARRAY) -- Inherit metadata warnings
    FROM CORE.RAW_TENABLE_VUL r
    JOIN TEMP_ASSET_METADATA met on met.TEMP_DW_ASSET_ID = r.TEMP_DW_ASSET_ID
    WHERE r.SNAPSHOT_ID = :P_SNAPSHOT_ID 
    and upd.RAW_TENABLE_VUL_ID = r.RAW_TENABLE_VUL_ID;

    RECORD_COUNT := SQLROWCOUNT;

    Msg := ''AWS CREDENTIALED_SCAN assigned='' || :RECORD_COUNT;
    CALL CORE.SP_CRM_WRITE_MSGLOG (:Appl,:Msg);
    COMMIT;
    END;
End If;

If (:DATACATEGORY IN (:MAG_VUL,:MAG_VUL_MITIGATED)) THEN -- 241023 CR1012
    BEGIN
    BEGIN TRANSACTION; 
    --
    -- Assign CREDENTIALED_SCAN already determined by SP_CRM_LINK_METADATA_V2
    --
    UPDATE CORE.RAW_TENABLE_VUL upd
    set CREDENTIALED_SCAN = met.IS_TENABLE_CREDENTIALED_SCAN::number
    FROM CORE.RAW_TENABLE_VUL r
    JOIN TEMP_ASSET_METADATA met on met.TEMP_DW_ASSET_ID = r.TEMP_DW_ASSET_ID
    WHERE r.SNAPSHOT_ID = :P_SNAPSHOT_ID 
    and upd.RAW_TENABLE_VUL_ID = r.RAW_TENABLE_VUL_ID;

    RECORD_COUNT := SQLROWCOUNT;

    Msg := ''MAG CREDENTIALED_SCAN assigned='' || :RECORD_COUNT;
    CALL CORE.SP_CRM_WRITE_MSGLOG (:Appl,:Msg);
    COMMIT;
    END;
End If;

--
-- This may overlay SYSTEM_ID set my metadata above
--
BEGIN TRANSACTION; -- 240419 CR 875
--
-- 240419 CR 875 Integrate new CCSQ lookup table for assigning FISMA ID based on Repository ID
--
UPDATE CORE.RAW_TENABLE_VUL upd
set SYSTEM_ID = s.SYSTEM_ID
FROM CORE.RAW_TENABLE_VUL r
-- 250110 JOIN REF_LOOKUPS.SHARED.SEC_MV_CCSQ_FISMA_LOOKUP lu on lu.REPOSITORY_ID = r.REPOSITORY_ID
-- 250113 corrected typo in view name
JOIN REF_LOOKUPS.SHARED.SEC_MV_CCSQ_TENABLE_REPOS_FISMA_LOOKUP lu on lu.REPOSITORY_ID = r.REPOSITORY_ID -- 250110 PE cloned/renamed view
JOIN CORE.VW_SYSTEMS s on s.SYSTEM_ID = lu.CFACTS_UID
where r.SNAPSHOT_ID = :P_SNAPSHOT_ID 
and upd.RAW_TENABLE_VUL_ID = r.RAW_TENABLE_VUL_ID;

RECORD_COUNT := SQLROWCOUNT;

Msg := ''CCSQ_FISMA_LOOKUP assigned='' || :RECORD_COUNT;
CALL CORE.SP_CRM_WRITE_MSGLOG (:Appl,:Msg);
COMMIT;

-- Empty DATACENTER_ID; Null or Empty
UPDATE CORE.RAW_TENABLE_VUL
set ROWDISPOSITION = CORE.FN_CRM_GET_ROWDISPOSITION_ERROR()
,DATA_ERROR_ARRAY = ARRAY_APPEND(DATA_ERROR_ARRAY,''Empty DATACENTER_ID'')
where SNAPSHOT_ID = :P_SNAPSHOT_ID and NULLIF(DATACENTER_ID,'''') IS NULL;

RECORD_COUNT := SQLROWCOUNT;
Msg := ''WARNING: Empty DATACENTER_ID='' || :RECORD_COUNT;
CALL CORE.SP_CRM_WRITE_MSGLOG (:Appl,:Msg); 

-- DATACENTER_ID does not exist
UPDATE CORE.RAW_TENABLE_VUL
set ROWDISPOSITION = CORE.FN_CRM_GET_ROWDISPOSITION_ERROR()
,DATA_ERROR_ARRAY = ARRAY_APPEND(r.DATA_ERROR_ARRAY,''DATACENTER_ID does not exist'')
FROM CORE.RAW_TENABLE_VUL r
LEFT OUTER JOIN CORE.SYSTEMS dc on upper(dc.system_id) = upper(r.DATACENTER_ID)
where r.RAW_TENABLE_VUL_ID = CORE.RAW_TENABLE_VUL.RAW_TENABLE_VUL_ID and r.SNAPSHOT_ID = :P_SNAPSHOT_ID
and NULLIF(r.DATACENTER_ID,'''') IS NOT NULL and dc.SYSTEM_ID IS NULL;


If (upper(:DATACATEGORY) IN (:AWS_VUL,:AWS_VUL_MITIGATED)) THEN -- 240727 CR928 This probably no longr needed
    BEGIN
    UPDATE CORE.RAW_TENABLE_VUL
    set ROWDISPOSITION = CORE.FN_CRM_GET_ROWDISPOSITION_ERROR()
    ,DATA_ERROR_ARRAY = ARRAY_APPEND(DATA_ERROR_ARRAY,''Instance ID is null in AWS datastream'')
    where SNAPSHOT_ID = :P_SNAPSHOT_ID and NULLIF(AWS_INSTANCE_ID,'''') IS NULL;
    END;
End If;

-- Validate DRaaS-CACHE. We expect all DRaaS assets to have the tenant tag format except for non-tattooable assets like network devices
-- 240912 CR978
UPDATE CORE.RAW_TENABLE_VUL
set ROWDISPOSITION = CORE.FN_CRM_GET_ROWDISPOSITION_ERROR()
,DATA_ERROR_ARRAY = ARRAY_APPEND(DATA_ERROR_ARRAY,''Invalid DRaaS-CACHE ASSET_ID_TAG'')
where SNAPSHOT_ID = :P_SNAPSHOT_ID 
and DATACENTER_ID = ''441a2d4fdbfbab00560cf9531f961911''
and CORE.FN_CRM_IS_VALID_DRAAS_ASSET_ID_TATTOO(ASSET_ID_TAG) = 0;

-- 240912 CR978
UPDATE CORE.RAW_TENABLE_VUL
set DATA_WARNING_ARRAY = ARRAY_APPEND(DATA_WARNING_ARRAY,''DRaaS-CACHE ASSET_ID_TAG is empty'')
where SNAPSHOT_ID = :P_SNAPSHOT_ID 
and DATACENTER_ID = ''441a2d4fdbfbab00560cf9531f961911''
and ASSET_ID_TAG IS NULL;

If (:DATACATEGORY IN (:MAG_VUL,:MAG_VUL_MITIGATED)) THEN -- 241023 CR1012
    BEGIN
    BEGIN TRANSACTION; 

    UPDATE CORE.RAW_TENABLE_VUL
    set ROWDISPOSITION = CORE.FN_CRM_GET_ROWDISPOSITION_ERROR()
    ,DATA_ERROR_ARRAY = ARRAY_APPEND(DATA_ERROR_ARRAY,''MAG ASSET_ID_TAG is empty'')
    where SNAPSHOT_ID = :P_SNAPSHOT_ID 
    and ASSET_ID_TAG IS NULL;

    UPDATE CORE.RAW_TENABLE_VUL
    set ROWDISPOSITION = CORE.FN_CRM_GET_ROWDISPOSITION_ERROR()
    ,DATA_ERROR_ARRAY = ARRAY_APPEND(DATA_ERROR_ARRAY,''MAG FISMA_ID_TAG is empty'')
    where SNAPSHOT_ID = :P_SNAPSHOT_ID 
    and FISMA_ID_TAG IS NULL;
    
    COMMIT;
    END;
End If;

UPDATE CORE.RAW_TENABLE_VUL
set ROWDISPOSITION = CORE.FN_CRM_GET_ROWDISPOSITION_ERROR()
,DATA_ERROR_ARRAY = ARRAY_APPEND(DATA_ERROR_ARRAY,''Invalid ASSET_ID_TATTOO'')
where SNAPSHOT_ID = :P_SNAPSHOT_ID and NULLIF(ASSET_ID_TATTOO,'''') IS NOT NULL -- 240917 CR978 added NULLIF
and CORE.FN_CRM_IS_VALID_ASSET_ID_TATTOO(ASSET_ID_TATTOO) = FALSE;

-- Validate PRIMARY_FISMA_ID_TATTOO/PRIMARY_FISMA_ID_DERIVED
UPDATE CORE.RAW_TENABLE_VUL
set ROWDISPOSITION = CORE.FN_CRM_GET_ROWDISPOSITION_ERROR()
,DATA_ERROR_ARRAY = ARRAY_APPEND(r.DATA_ERROR_ARRAY,''Invalid PRIMARY_FISMA_ID'')
FROM CORE.RAW_TENABLE_VUL r
LEFT OUTER JOIN CORE.SYSTEMS s on upper(s.system_id) = coalesce(upper(r.PRIMARY_FISMA_ID_TATTOO),upper(r.PRIMARY_FISMA_ID_DERIVED))
where r.RAW_TENABLE_VUL_ID = CORE.RAW_TENABLE_VUL.RAW_TENABLE_VUL_ID and r.SNAPSHOT_ID = :P_SNAPSHOT_ID 
and (r.PRIMARY_FISMA_ID_TATTOO IS NOT NULL OR r.PRIMARY_FISMA_ID_DERIVED IS NOT NULL) and s.SYSTEM_ID IS NULL;

RECORD_COUNT := SQLROWCOUNT;
Msg := ''WARNING: Validate PRIMARY_FISMA_ID='' || :RECORD_COUNT;
CALL CORE.SP_CRM_WRITE_MSGLOG (:Appl,:Msg);

-- Assign SYSTEM_ID (if not already assigned) based on PRIMARY_FISMA_ID_TATTOO or PRIMARY_FISMA_ID_DERIVED
UPDATE CORE.RAW_TENABLE_VUL
set SYSTEM_ID = s.SYSTEM_ID
FROM CORE.RAW_TENABLE_VUL r
JOIN CORE.SYSTEMS s on upper(s.system_id) = coalesce(upper(r.PRIMARY_FISMA_ID_TATTOO),upper(r.PRIMARY_FISMA_ID_DERIVED))
where r.RAW_TENABLE_VUL_ID = CORE.RAW_TENABLE_VUL.RAW_TENABLE_VUL_ID and r.SNAPSHOT_ID = :P_SNAPSHOT_ID 
and (r.PRIMARY_FISMA_ID_TATTOO IS NOT NULL OR r.PRIMARY_FISMA_ID_DERIVED IS NOT NULL) and r.SYSTEM_ID IS NULL;

RECORD_COUNT := SQLROWCOUNT;
Msg := ''WARNING: Assign PRIMARY_FISMA_ID='' || :RECORD_COUNT;
CALL CORE.SP_CRM_WRITE_MSGLOG (:Appl,:Msg); 

UPDATE CORE.RAW_TENABLE_VUL
set ROWDISPOSITION = CORE.FN_CRM_GET_ROWDISPOSITION_ERROR()
,DATA_ERROR_ARRAY = ARRAY_APPEND(DATA_ERROR_ARRAY,''No IP available'')
where SNAPSHOT_ID = :P_SNAPSHOT_ID and IP IS NULL;

UPDATE CORE.RAW_TENABLE_VUL
set ROWDISPOSITION = CORE.FN_CRM_GET_ROWDISPOSITION_ERROR()
,DATA_ERROR_ARRAY = ARRAY_APPEND(DATA_ERROR_ARRAY,''ASSET_ID_TATTOO,DNSNAME,HOSTNAME,NETBIOSNAME are null'')
where SNAPSHOT_ID = :P_SNAPSHOT_ID 
and ASSET_ID_TATTOO IS NULL and DNSNAME	IS NULL and HOSTNAME IS NULL and NETBIOSNAME IS NULL;

-- SYSTEM_ID could not be assigned using system ID related data contained within the RAW_HWAM record.
-- See if MDR(Asset) record already exists and use its SYSTEM_ID
UPDATE CORE.RAW_TENABLE_VUL upd
set SYSTEM_ID = a.SYSTEM_ID
,DATA_WARNING_ARRAY = ARRAY_APPEND(r.DATA_WARNING_ARRAY,''SYSTEM_ID obtained from ASSET table based on ASSET_ID_TATTOO'')
FROM CORE.RAW_TENABLE_VUL r
JOIN CORE.ASSET a on a.DATACENTER_ID = r.DATACENTER_ID and a.ASSET_ID_TATTOO = r.ASSET_ID_TATTOO
where r.RAW_TENABLE_VUL_ID = upd.RAW_TENABLE_VUL_ID and r.SNAPSHOT_ID = :P_SNAPSHOT_ID and r.SYSTEM_ID IS NULL;

RECORD_COUNT := SQLROWCOUNT;
Msg := ''SYSTEM_ID from ASSET table used='' || :RECORD_COUNT;
CALL CORE.SP_CRM_WRITE_MSGLOG (:Appl,:Msg);

UPDATE CORE.RAW_TENABLE_VUL
set ROWDISPOSITION = CORE.FN_CRM_GET_ROWDISPOSITION_ERROR()
,DATA_ERROR_ARRAY = ARRAY_APPEND(r.DATA_ERROR_ARRAY,''Invalid SYSTEM_ID'')
FROM CORE.RAW_TENABLE_VUL r
LEFT OUTER JOIN CORE.SYSTEMS s on upper(s.system_id) = upper(r.SYSTEM_ID)
where r.RAW_TENABLE_VUL_ID = CORE.RAW_TENABLE_VUL.RAW_TENABLE_VUL_ID and r.SNAPSHOT_ID = :P_SNAPSHOT_ID 
and NULLIF(r.SYSTEM_ID,'''') IS NOT NULL and s.SYSTEM_ID IS NULL;

--
-- When no SYSTEM_ID is available default it to the DATACENTER_ID
--
UPDATE CORE.RAW_TENABLE_VUL upd
set SYSTEM_ID = r.DATACENTER_ID
,IS_PRIMARY_FISMA_ID_DEFAULTED_TO_DC = :True
,DATA_WARNING_ARRAY = ARRAY_APPEND(r.DATA_WARNING_ARRAY,''SYSTEM_ID defaulted to DATACENTER_ID'')
FROM CORE.RAW_TENABLE_VUL r
JOIN CORE.SYSTEMS dc on dc.SYSTEM_ID = r.DATACENTER_ID
where r.RAW_TENABLE_VUL_ID = upd.RAW_TENABLE_VUL_ID and r.SNAPSHOT_ID = :P_SNAPSHOT_ID and r.SYSTEM_ID IS NULL;

RECORD_COUNT := SQLROWCOUNT;

If (:RECORD_COUNT > 0) THEN
    BEGIN
    Msg := ''SYSTEM_ID defaulted to DATACENTER_ID='' || :RECORD_COUNT;
    CALL CORE.SP_CRM_WRITE_MSGLOG (:Appl,:Msg);   
    END;
END IF;

UPDATE CORE.RAW_TENABLE_VUL
set ROWDISPOSITION = CORE.FN_CRM_GET_ROWDISPOSITION_ERROR()
,DATA_ERROR_ARRAY = ARRAY_APPEND(r.DATA_ERROR_ARRAY,''SYSTEM_ID could not be assigned'')
FROM CORE.RAW_TENABLE_VUL r
where r.RAW_TENABLE_VUL_ID = CORE.RAW_TENABLE_VUL.RAW_TENABLE_VUL_ID and r.SNAPSHOT_ID = :P_SNAPSHOT_ID and r.SYSTEM_ID IS NULL;

RECORD_COUNT := SQLROWCOUNT;

If (:RECORD_COUNT > 0) THEN
    BEGIN
    Msg := ''RESEARCH WHY SYSTEM_ID NOT ASSIGNED='' || :RECORD_COUNT;
    CALL CORE.SP_CRM_WRITE_MSGLOG (:Appl,:Msg);   
    END;
END IF;

--
-- UPDATE SNAPSHOT_IDS with Error and Warning counts
--
select SUM(ARRAY_SIZE(DATA_ERROR_ARRAY)),SUM(ARRAY_SIZE(DATA_WARNING_ARRAY)) into :ERROR_COUNT,:WARNING_COUNT FROM CORE.RAW_TENABLE_VUL where SNAPSHOT_ID = :P_SNAPSHOT_ID;
select count(1) into :RECORDS_WITH_ERRORS FROM CORE.RAW_TENABLE_VUL where SNAPSHOT_ID = :P_SNAPSHOT_ID and ARRAY_SIZE(DATA_ERROR_ARRAY) > 0;
select count(1) into :RECORDS_WITH_WARNINGS FROM CORE.RAW_TENABLE_VUL where SNAPSHOT_ID = :P_SNAPSHOT_ID and ARRAY_SIZE(DATA_WARNING_ARRAY) > 0;

UPDATE SNAPSHOT_IDS
set ERROR_COUNT = :ERROR_COUNT
,RECORDS_WITH_ERRORS = :RECORDS_WITH_ERRORS
,RECORDS_WITH_WARNINGS = :RECORDS_WITH_WARNINGS
,WARNING_COUNT = :WARNING_COUNT
WHERE SNAPSHOT_ID = :P_SNAPSHOT_ID;

--
-- The CCIC vulnerability data includes On-Prem vulnerabilities and AWS vulnerabilities.
-- When processing the CCIC vulnerability data exclude AWS vulnerability data because it
-- is processed in a separate vulnerability data-stream specific to AWS
--
If (upper(:DATACATEGORY) IN (:CCIC_VUL,:CCIC_VUL_MITIGATED)) THEN
    BEGIN
    --
    -- (AWS OC East) is the same thing as (AWS Vulnerabilities) except SecEng renames it to (AWS Vulnerabilities) within the CCIC security center server
    --
    UPDATE CORE.RAW_TENABLE_VUL upd
    set APPLICABILITYCODE = ''Excluding AWS VUL from CCIC VUL FEED''
    ,ROWDISPOSITION = CORE.FN_CRM_GET_ROWDISPOSITION_NOT_NEEDED()
    FROM CORE.RAW_TENABLE_VUL r
    where r.RAW_TENABLE_VUL_ID = upd.RAW_TENABLE_VUL_ID and r.SNAPSHOT_ID = :P_SNAPSHOT_ID and r.REPOSITORY_ID = 14;
    END;
End if;

UPDATE CORE.RAW_TENABLE_VUL
set APPLICABILITYCODE = ''CVE is empty''
,ROWDISPOSITION = CORE.FN_CRM_GET_ROWDISPOSITION_NOT_NEEDED()
FROM CORE.RAW_TENABLE_VUL r
where r.RAW_TENABLE_VUL_ID = CORE.RAW_TENABLE_VUL.RAW_TENABLE_VUL_ID and r.SNAPSHOT_ID = :P_SNAPSHOT_ID and r.APPLICABILITYCODE = CORE.FN_CRM_GET_INDICATOR_INITIAL() and ARRAY_SIZE(r.CVE) = 0;

UPDATE CORE.RAW_TENABLE_VUL
set APPLICABILITYCODE = ''SEVERITY_NAME is empty''
,ROWDISPOSITION = CORE.FN_CRM_GET_ROWDISPOSITION_NOT_NEEDED()
FROM CORE.RAW_TENABLE_VUL r
where r.RAW_TENABLE_VUL_ID = CORE.RAW_TENABLE_VUL.RAW_TENABLE_VUL_ID and r.SNAPSHOT_ID = :P_SNAPSHOT_ID and r.APPLICABILITYCODE = CORE.FN_CRM_GET_INDICATOR_INITIAL() and (r.SEVERITY_NAME IS NULL or r.SEVERITY_NAME = '''');

UPDATE CORE.RAW_TENABLE_VUL
set APPLICABILITYCODE = ''SEVERITY_NAME is Info''
,ROWDISPOSITION = CORE.FN_CRM_GET_ROWDISPOSITION_NOT_NEEDED()
FROM CORE.RAW_TENABLE_VUL r
where r.RAW_TENABLE_VUL_ID = CORE.RAW_TENABLE_VUL.RAW_TENABLE_VUL_ID 
and r.SNAPSHOT_ID = :P_SNAPSHOT_ID and r.APPLICABILITYCODE = CORE.FN_CRM_GET_INDICATOR_INITIAL() 
and (upper(r.FISMASEVERITY) = ''INFO''); -- 240911 CR976
-- 240911 CR976 and (upper(r.SEVERITY_NAME) = ''INFO'');

UPDATE CORE.RAW_TENABLE_VUL
set APPLICABILITYCODE = ''CVSS is zero''
,ROWDISPOSITION = CORE.FN_CRM_GET_ROWDISPOSITION_NOT_NEEDED()
where SNAPSHOT_ID = :P_SNAPSHOT_ID and APPLICABILITYCODE = CORE.FN_CRM_GET_INDICATOR_INITIAL() and CVSSV3BASESCORE = 0;


--
-- 241023 CR1012
-- These plugins not used as of this date but marking them for visibility sake
--
-- 99172 Microsoft Azure Instance Metadata Enumeration (Windows)
-- 99171 Microsoft Azure Instance Metadata Enumeration (Unix)
--
UPDATE CORE.RAW_TENABLE_VUL
set APPLICABILITYCODE = ''Metadata''
,ROWDISPOSITION = CORE.FN_CRM_GET_ROWDISPOSITION_NOT_NEEDED()
where SNAPSHOT_ID = :P_SNAPSHOT_ID and APPLICABILITYCODE = CORE.FN_CRM_GET_INDICATOR_INITIAL() 
and PLUGIN_ID IN (''90191'',''90427'',''1221295'',''1218405'',''19506'',''99171'',''99172''); 

CALL CORE.SP_CRM_END_PROCEDURE (:Appl);
return ''Success'';

EXCEPTION
  when statement_error then
    insert into CORE.ALERTLOG (APPL,CUSTOM_ERRMSG,ERRTYPE,SQLCODE,SQLERRM,SQLSTATE) VALUES(:APPL,:ExceptionMsg,''Statement_Error'',:SQLCODE,:SQLERRM,:SQLSTATE);
    raise;
  when CRM_logic_exception then
    insert into CORE.ALERTLOG (APPL,CUSTOM_ERRMSG,ERRTYPE,SQLCODE,SQLERRM,SQLSTATE) VALUES(:APPL,:ExceptionMsg,''CRM_logic_exception'',:SQLCODE,:SQLERRM,:SQLSTATE);
    raise;
  when other then
    insert into CORE.ALERTLOG (APPL,CUSTOM_ERRMSG,ERRTYPE,SQLCODE,SQLERRM,SQLSTATE) VALUES(:APPL,:ExceptionMsg,''Other error'',:SQLCODE,:SQLERRM,:SQLSTATE);
    raise;
END
';