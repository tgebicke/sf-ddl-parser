CREATE OR REPLACE PROCEDURE "SP_CRM_LOAD_VULPLUGINS_MASTER"("P_SNAPSHOT_ID" NUMBER(38,0))
RETURNS VARCHAR(16777216)
LANGUAGE SQL
COMMENT='Load/Update VULPLUGINS_MASTER table'
EXECUTE AS OWNER
AS '
declare
Appl varchar := ''SP_CRM_LOAD_VULPLUGINS_MASTER'';
ExceptionMsg varchar;
Msg varchar;
StartOfProgram datetime := current_timestamp();
CRM_logic_exception exception (-20002, ''Raised CRM_logic_exception.'');
RowDispositionViable varchar := ''Viable''; -- 240121 added back
ApplicabilityCode_Actionable varchar := ''Actionable'';
ApplicabilityCode_Initial varchar := ''Initial''; -- 240121 added back
AWS_VulnerabilityDataStream varchar := ''AWS VUL'';
CCIC_VulnerabilityDataStream varchar := ''CCIC VUL'';
MAG_VulnerabilityDataStream varchar := ''MAG VUL''; -- 241023 CR1012
DATACATEGORY VARCHAR;
IS_FROM_AWS_FEED BOOLEAN;
RECORD_COUNT number;

BEGIN
select DATACATEGORY,IS_FROM_AWS_FEED into :DATACATEGORY,:IS_FROM_AWS_FEED FROM CORE.SNAPSHOT_IDS where SNAPSHOT_ID = :P_SNAPSHOT_ID;
Appl := :Appl || ''('' || DATACATEGORY || '')''; -- This helps to clarify which VUL we are processing
CALL CORE.SP_CRM_START_PROCEDURE (:Appl);

-- 241023 CR1012 added MAG_VulnerabilityDataStream
IF (upper(:DATACATEGORY) NOT IN (:AWS_VulnerabilityDataStream,:CCIC_VulnerabilityDataStream,:MAG_VulnerabilityDataStream)) THEN
	BEGIN
	Msg := ''DataCategory not vaild in this stored procedure'';
	CALL CORE.SP_CRM_WRITE_MSGLOG (:Appl,:Msg);
    CALL CORE.SP_CRM_END_PROCEDURE (:Appl);
	RETURN :Msg;
	END;
END IF;

BEGIN TRANSACTION; -- 240121 this transaction was on obsolete SP_CRM_LOAD_VULMASTER. Now adding it back in.

--
-- Determiine which rows are actionable. We want to yield one row for each DW_ASSET_ID/PLUGIN_ID
--
TRUNCATE TABLE TEMP_ACTIONABLE_VUL;

INSERT INTO CORE.TEMP_ACTIONABLE_VUL (DW_ASSET_ID,FIRST_SEEN,LAST_SEEN,PLUGIN_ID,RAW_TENABLE_VUL_ID)
with
actionable_cte as (
select DW_ASSET_ID,FIRST_SEEN,LAST_SEEN,PLUGIN_ID,RAW_TENABLE_VUL_ID
    FROM CORE.RAW_TENABLE_VUL 
    where SNAPSHOT_ID = :P_SNAPSHOT_ID
    and ROWDISPOSITION = :RowDispositionViable and APPLICABILITYCODE = :ApplicabilityCode_Initial and DW_ASSET_ID IS NOT NULL -- 240121 added DW_ASSET_ID
),
last_seen_cte as(
select dw_asset_id,PLUGIN_ID,last_seen,RAW_TENABLE_VUL_ID from (
    select distinct dw_asset_id,PLUGIN_ID,last_seen,RAW_TENABLE_VUL_ID,dense_rank() over (partition by dw_asset_id,PLUGIN_ID order by last_seen desc, RAW_TENABLE_VUL_ID desc) rank --
    from actionable_cte
    ) where rank=1
),
first_seen_cte as 
    (select a.dw_asset_id,a.plugin_id,min(a.first_seen) as Min_First_Seen
    FROM actionable_cte a
    join last_seen_cte ls on ls.dw_asset_id = a.dw_asset_id and ls.last_seen = a.last_seen
    group by a.dw_asset_id,a.plugin_id
)
select v.dw_asset_id, f.Min_First_Seen, v.last_seen,v.PLUGIN_ID ,v.RAW_TENABLE_VUL_ID
FROM actionable_cte v
join last_seen_cte l on l.RAW_TENABLE_VUL_ID = v.RAW_TENABLE_VUL_ID
join first_seen_cte f on f.dw_asset_id = v.dw_asset_id and f.plugin_id = v.plugin_id;

Msg := ''Populated TEMP_ACTIONABLE_VUL'';
CALL CORE.SP_CRM_WRITE_MSGLOG (:Appl,:Msg);

--
-- 240121 probably dont need where clause but verify and remove at a later date
--
UPDATE CORE.RAW_TENABLE_VUL upd
set APPLICABILITYCODE = :ApplicabilityCode_Actionable
FROM CORE.RAW_TENABLE_VUL r
JOIN CORE.TEMP_ACTIONABLE_VUL t on t.RAW_TENABLE_VUL_ID = r.RAW_TENABLE_VUL_ID -- 240121 exact record already known
where upd.RAW_TENABLE_VUL_ID = r.RAW_TENABLE_VUL_ID;
-- 240121 where r.RAW_TENABLE_VUL_ID = CORE.RAW_TENABLE_VUL.RAW_TENABLE_VUL_ID and r.SNAPSHOT_ID = :P_SNAPSHOT_ID 
-- 240121 and r.ROWDISPOSITION = :RowDispositionViable and r.APPLICABILITYCODE = :ApplicabilityCode_Initial;

Msg := ''Set RAW_TENABLE_VUL to Actionable'';
CALL CORE.SP_CRM_WRITE_MSGLOG (:Appl,:Msg);

COMMIT;


BEGIN TRANSACTION;

MERGE INTO CORE.VULPLUGINS_MASTER as target
USING (SELECT
r.CREDENTIALED_SCAN
,r.CVE
,r.CVSSV2BASESCORE
,r.CVSSV3BASESCORE
,datediff(day,r.FIRST_SEEN,r.LAST_SEEN) as DAYSSINCEDISCOVERY
,r.DESCRIPTION
,r.DW_ASSET_ID
,r.EXPLOIT_AVAILABLE as EXPLOITAVAILABLE
,r.FAMILY_ID
,r.FAMILY_NAME
,r.FAMILY_TYPE
,r.FIRST_SEEN as FIRSTSEEN
,r.FISMASEVERITY
,r.HAS_BEEN_MITIGATED
,r.LAST_SEEN as LASTFOUND
,r.MITIGATIONSTATUS
,r.NESSUS_VERSION
,r.NUMERIC_SEVERITY
,r.PATCHPUB_DATE
,r.PLUGIN_ID
,r.PLUGIN_INFO
,r.PLUGIN_MOD_DATE
,r.PLUGIN_NAME
,r.PLUGIN_PUB_DATE
,r.PORT
,r.REPOSITORY_ID
,r.REPOSITORY_NAME
,r.SCAN_POLICY_NAME
,r.SCAN_POLICY_UID
,r.SCAN_START_DATE
,r.SOLUTION
,r.SYNOPSIS
,r.TENABLEUUID
,r.VERSION
,r.VULN_PUB_DATE
from RAW_TENABLE_VUL r
JOIN TEMP_ACTIONABLE_VUL t on t.RAW_TENABLE_VUL_ID = r.RAW_TENABLE_VUL_ID -- 240121 replace where clause since exact record already known
-- 240121 where r.SNAPSHOT_ID = :P_SNAPSHOT_ID and r.APPLICABILITYCODE = :ApplicabilityCode_Actionable and r.DW_ASSET_ID IS NOT NULL

) as src 

ON (src.DW_ASSET_ID = target.DW_ASSET_ID and src.PLUGIN_ID = target.PLUGIN_ID)

WHEN MATCHED THEN UPDATE SET 
-- Never change DW_ASSET_ID or PLUGIN_ID
target.CREDENTIALED_SCAN = src.CREDENTIALED_SCAN
,target.CVE = src.CVE
,target.CVSSV2BASESCORE = src.CVSSV2BASESCORE
,target.CVSSV3BASESCORE = src.CVSSV3BASESCORE
,target.DATEDELETED = NULL
,target.DATEMITIGATED = NULL
,target.DATEMODIFIED = CURRENT_TIMESTAMP() -- DATEMODIFIED. Setting this is critical to SP_CRM_UPDATE_VULCVE_MASTER
,target.DATEREOPENED = CURRENT_TIMESTAMP()
,target.DAYSSINCEDISCOVERY = src.DAYSSINCEDISCOVERY
,target.DELETIONREASON = NULL
,target.DESCRIPTION = src.DESCRIPTION
--,target.DW_ASSET_ID
,target.EXPLOITAVAILABLE = src.EXPLOITAVAILABLE
,target.FAMILY_ID = src.FAMILY_ID
,target.FAMILY_NAME = src.FAMILY_NAME
,target.FAMILY_TYPE = src.FAMILY_TYPE
--,target.FIRSTSEEN
,target.FISMASEVERITY = src.FISMASEVERITY
,target.HAS_BEEN_MITIGATED = src.HAS_BEEN_MITIGATED
--,CURRENT_TIMESTAMP() -- INSERT_DATE
--,target.IS_FROM_AWS_FEED
,target.LASTFOUND = src.LASTFOUND
,target.MITIGATIONSTATUS = src.MITIGATIONSTATUS
,target.NESSUS_VERSION = src.NESSUS_VERSION
,target.NUMERIC_SEVERITY = src.NUMERIC_SEVERITY
,target.PATCHPUB_DATE = src.PATCHPUB_DATE
--,target.PLUGIN_ID
,target.PLUGIN_INFO = src.PLUGIN_INFO
,target.PLUGIN_MOD_DATE = src.PLUGIN_MOD_DATE
,target.PLUGIN_NAME = src.PLUGIN_NAME
,target.PLUGIN_PUB_DATE = src.PLUGIN_PUB_DATE
,target.PORT = src.PORT
,target.REPOSITORY_ID = src.REPOSITORY_ID
,target.REPOSITORY_NAME = src.REPOSITORY_NAME
,target.SCAN_POLICY_NAME = src.SCAN_POLICY_NAME
,target.SCAN_POLICY_UID = src.SCAN_POLICY_UID
,target.SCAN_START_DATE = src.SCAN_START_DATE
,target.SNAPSHOT_ID = :P_SNAPSHOT_ID
,target.SOLUTION = src.SOLUTION
,target.SYNOPSIS = src.SYNOPSIS
,target.TENABLEUUID = src.TENABLEUUID
,target.VERSION = src.VERSION
,target.VULN_PUB_DATE = src.VULN_PUB_DATE

WHEN NOT MATCHED THEN INSERT (
CREDENTIALED_SCAN
,CVE
,CVSSV2BASESCORE
,CVSSV3BASESCORE
,DATEDELETED
,DATEMITIGATED
,DATEMODIFIED
,DATEREOPENED
,DAYSSINCEDISCOVERY
,DELETIONREASON
,DESCRIPTION
,DW_ASSET_ID
,EXPLOITAVAILABLE
,FAMILY_ID
,FAMILY_NAME
,FAMILY_TYPE
,FIRSTSEEN
,FISMASEVERITY
,HAS_BEEN_MITIGATED
,INSERT_DATE
,IS_FROM_AWS_FEED
,LASTFOUND
,MITIGATIONSTATUS
,NESSUS_VERSION
,NUMERIC_SEVERITY
,PATCHPUB_DATE
,PLUGIN_ID
,PLUGIN_INFO
,PLUGIN_MOD_DATE
,PLUGIN_NAME
,PLUGIN_PUB_DATE
,PORT
,REPOSITORY_ID
,REPOSITORY_NAME
,SCAN_POLICY_NAME
,SCAN_POLICY_UID
,SCAN_START_DATE
,SNAPSHOT_ID
,SOLUTION
,SYNOPSIS
,TENABLEUUID
,VERSION
,VULN_PUB_DATE
)
VALUES (
src.CREDENTIALED_SCAN
,src.CVE
,src.CVSSV2BASESCORE
,src.CVSSV3BASESCORE
,NULL -- DATEDELETED
,NULL -- DATEMITIGATED
,CURRENT_TIMESTAMP() -- DATEMODIFIED. Setting this is critical to SP_CRM_UPDATE_VULCVE_MASTER
,NULL -- DATEREOPENED
,src.DAYSSINCEDISCOVERY -- DAYSSINCEDISCOVERY
,NULL -- DELETIONREASON
,src.DESCRIPTION
,src.DW_ASSET_ID
,src.EXPLOITAVAILABLE
,src.FAMILY_ID
,src.FAMILY_NAME
,src.FAMILY_TYPE
,src.FIRSTSEEN
,src.FISMASEVERITY
,src.HAS_BEEN_MITIGATED
,CURRENT_TIMESTAMP() -- INSERT_DATE
,:IS_FROM_AWS_FEED
,src.LASTFOUND
,src.MITIGATIONSTATUS
,src.NESSUS_VERSION
,src.NUMERIC_SEVERITY
,src.PATCHPUB_DATE
,src.PLUGIN_ID
,src.PLUGIN_INFO
,src.PLUGIN_MOD_DATE
,src.PLUGIN_NAME
,src.PLUGIN_PUB_DATE
,src.PORT
,src.REPOSITORY_ID
,src.REPOSITORY_NAME
,src.SCAN_POLICY_NAME
,src.SCAN_POLICY_UID
,src.SCAN_START_DATE
,:P_SNAPSHOT_ID
,src.SOLUTION
,src.SYNOPSIS
,src.TENABLEUUID
,src.VERSION
,src.VULN_PUB_DATE
);

Msg := ''Finished Merge'';
CALL CORE.SP_CRM_WRITE_MSGLOG (:Appl,:Msg);

COMMIT;

--
-- Now load the VULMASTER table which contains the CVEs related to each PluginID
-- E.g. PluginID can have one or more CVEs associated with it
--
CALL CORE.SP_CRM_LOAD_VULCVE_MASTER(:P_SNAPSHOT_ID);


CALL CORE.SP_CRM_END_PROCEDURE (:Appl);
return ''Success'';

EXCEPTION
  when statement_error then
    insert into CORE.ALERTLOG (APPL,CUSTOM_ERRMSG,ERRTYPE,SQLCODE,SQLERRM,SQLSTATE) VALUES(:APPL,:ExceptionMsg,''Statement_Error'',:SQLCODE,:SQLERRM,:SQLSTATE);
    raise;
  when CRM_logic_exception then
    insert into CORE.ALERTLOG (APPL,CUSTOM_ERRMSG,ERRTYPE,SQLCODE,SQLERRM,SQLSTATE) VALUES(:APPL,:ExceptionMsg,''CRM_logic_exception'',:SQLCODE,:SQLERRM,:SQLSTATE);
    raise;
  when other then
    insert into CORE.ALERTLOG (APPL,CUSTOM_ERRMSG,ERRTYPE,SQLCODE,SQLERRM,SQLSTATE) VALUES(:APPL,:ExceptionMsg,''Other error'',:SQLCODE,:SQLERRM,:SQLSTATE);
    raise;
END;
';